extern crate rand;
extern crate sha1;

use std::fs::File;
use std::io::Read;

use self::rand::prelude::*;
use self::sha1::Sha1;

fn read_bytes(filename: &str) -> Vec<u8> {
    let mut f = File::open(filename).unwrap();
    let mut buffer: Vec<u8> = vec![];
    f.read_to_end(&mut buffer).expect("Couldn`t read to string");
    buffer
}

/// Computes SHA1 HEX digest of the file
///
/// # Examples
///
/// ```rust
/// let digest = hash_file("filetoprint.pdf"); // <SHA1 hexadecimal digest>
/// ```
pub fn hash_file(filename: &str) -> String {
    let mybytes = read_bytes(&filename);
    let mut hasher = Sha1::new();
    hasher.update(&mybytes);
    hasher.digest().to_string()
}

/// Computes SHA1 HEX digest of the bytes you provide
///
/// # Examples
///
/// ```rust
/// let data: Vec<u8> = vec![0, 5, 6, 58];
/// println!("{}", hash_data(&data)); // <SHA1 hexadecimal digest>
/// ```
pub fn hash_data(data: &Vec<u8>) -> String {
    let mut hasher = Sha1::new();
    hasher.update(data);
    hasher.digest().to_string()
}


/// Generates token from the name
///
/// Token is generates by the rule `<your name><hex digest>`, where `<hex digest>` is
/// generated by hashing the name and 64 pseudo random bytes.
///
/// # Examples
///
/// ```rust
/// println!("{}", generate_token("IFMO")); // IFMO<some SHA1 hex digest>
/// ```
pub fn generate_token(name: String) -> String {
    let mut rng = rand::thread_rng();
    let mut data = Vec::from(name.clone());
    for _ in 0..64 {
        data.push(rng.gen::<u8>());
    }
    format!("{}{}", &name, hash_data(&data))
}