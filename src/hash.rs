extern crate rand;
extern crate sha1;

use std::fs::File;
use std::io::Read;

use self::rand::prelude::*;
use self::sha1::Sha1;

fn read_bytes(filename: &str) -> Result<Vec<u8>, String> {
    let mut f = match File::open(filename) {
        Ok(data) => data,
        Err(err) => {
            eprintln!("{:?}", err);
            return Err(format!("{:?}", err));
        }
    };
    let mut buffer: Vec<u8> = vec![];
    match f.read_to_end(&mut buffer) {
        Ok(_) => Ok(buffer),
        Err(err) => {
            eprintln!("{:?}", err);
            return Err(format!("{:?}", err));
        }
    }
}

/// Computes SHA1 HEX digest of the file
///
/// # Examples
///
/// ```rust
/// let digest = hash_file("filetoprint.pdf"); // <SHA1 hexadecimal digest>
/// ```
pub fn hash_file(filename: &str) -> Result<String, String> {
    let mybytes = match read_bytes(&filename) {
        Ok(data) => data,
        Err(err) => {
            eprintln!("{:?}", err);
            return Err(format!("{:?}", err));
        }
    };
    let mut hasher = Sha1::new();
    hasher.update(&mybytes);
    Ok(hasher.digest().to_string())
}

/// Computes SHA1 HEX digest of the bytes you provide
///
/// # Examples
///
/// ```rust
/// let data: Vec<u8> = vec![0, 5, 6, 58];
/// println!("{}", hash_data(&data)); // <SHA1 hexadecimal digest>
/// ```
pub fn hash_data(data: &Vec<u8>) -> String {
    let mut hasher = Sha1::new();
    hasher.update(data);
    hasher.digest().to_string()
}


/// Generates token from the name
///
/// Token is generates by the rule `<your name><hex digest>`, where `<hex digest>` is
/// generated by hashing the name and 64 pseudo random bytes.
///
/// # Examples
///
/// ```rust
/// println!("{}", generate_token("IFMO")); // IFMO<some SHA1 hex digest>
/// ```
pub fn generate_token(name: String) -> String {
    let mut rng = rand::thread_rng();
    let mut data = Vec::from(name.clone());
    for _ in 0..64 {
        data.push(rng.gen::<u8>());
    }
    format!("{}{}", &name, hash_data(&data))
}